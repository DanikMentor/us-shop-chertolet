from flask import Flask, render_template_string, jsonify, request
import random

app = Flask(__name__)

# Список участников и их шансы
items = [
    ("Никита", 1),
    ("Арсений", 1),
    ("Максон", 1),
    ("Костя", 1),
    ("Илья", 1),
    ("Дима", 1),
    ("Саша", 1),
    ("Паша", 1),
]

total_weight = sum(weight for name, weight in items)

# HTML
HTML = """
<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<title>Колесо фортуны</title>
<style>
body { 
    text-align: center; 
    font-family: sans-serif; 
    margin-top: 50px; 
}
#wheel-container { 
    position: relative; 
    width: 400px; 
    height: 400px; 
    margin: auto; 
}
#wheel {
    width: 100%; 
    height: 100%; 
    border-radius: 50%;
    position: relative;
    border: 3px solid #000;
    overflow: hidden;
    /* transition will be set dynamically per-spin for random speed */
}

/* Arrow pointer that indicates the winner (points toward the wheel) */
#arrow {
    position: absolute;
    top: 20px;            /* adjust to place the arrow just above the wheel */
    left: 50%;
    right: 50%;
    margin-top: -190px;  /* adjust based on arrow size */
    transform: translateX(-50%) rotate(270deg); /* point downwards */
    width: 0;
    height: 0;
    border-left: 18px solid transparent;
    border-right: 18px solid transparent;
    border-bottom: 26px solid #e33; /* arrow color */
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    z-index: 5;
}

/* labels placed around the wheel */
.label {
    position: absolute;
    top: 50%;
    left: 50%;
    transform-origin: 0 0;
    font-weight: bold;
    white-space: nowrap;
    padding: 2px 6px;
    pointer-events: none;
    color: #111;
    text-shadow: 0 1px 0 rgba(255,255,255,0.6);
}

button { 
    margin-top: 20px; 
    padding: 12px 30px;
    font-size: 18px;
    background-color: #28a745;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
}
button[disabled] {
    opacity: 0.6;
    cursor: not-allowed;
}
button:hover:not([disabled]) { 
    background-color: #218838;
}
#result { 
    margin-top: 20px; 
    font-size: 20px; 
    font-weight: bold;
    min-height: 24px;
}
</style>
</head>
<body>
<div id="wheel-container">
    <div id="arrow" aria-hidden="true"></div>
    <div id="wheel">
        <!-- Segments and labels will be generated by JavaScript -->
    </div>
</div>
<button id="spinBtn" onclick="spin()">Крутить</button>
<div id="result"></div>

<script>
let currentRotation = 0;

function createWheel() {
    const wheel = document.getElementById('wheel');
    wheel.innerHTML = ''; // clear
    const items = {{ items|tojson }};
    const totalWeight = items.reduce((sum, item) => sum + item[1], 0);
    let startAngle = 0;
    const gradientParts = [];
    const radius = wheel.clientWidth / 2 * 0.75; // distance from center for labels

    items.forEach(([name, weight], index) => {
        const segmentAngle = (weight / totalWeight) * 360;
        const endAngle = startAngle + segmentAngle;
        const color = `hsl(${(index / items.length) * 360}, 70%, 70%)`;
        gradientParts.push(`${color} ${startAngle}deg ${endAngle}deg`);

        // create label at middle angle
        const mid = startAngle + segmentAngle / 2;
        const label = document.createElement('div');
        label.className = 'label';
        // rotate to angle, move outward, then flip text if on bottom half
        const flip = (mid > 90 && mid < 270) ? 180 : 0;
        label.style.transform = `rotate(${mid}deg) translateX(${radius}px) rotate(${flip}deg)`;
        label.innerText = name;
        wheel.appendChild(label);

        startAngle = endAngle;
    });

    wheel.style.background = `conic-gradient(${gradientParts.join(',')})`;
}

window.onload = createWheel;

// spin now animates first, then determines winner by where arrow points (sent to server)
function spin() {
    const btn = document.getElementById('spinBtn');
    if (btn.disabled) return;
    btn.disabled = true;
    document.getElementById('result').innerText = '';

    const wheel = document.getElementById('wheel');
    const items = {{ items|tojson }};
    const totalWeight = items.reduce((sum, item) => sum + item[1], 0);

    // pick a random visual spin (no server-side random winner anymore)
    // compute a random target that will determine which segment ends under arrow
    let startAngle = 0;
    const segmentAngles = items.map(([name, weight]) => {
        const a = (weight / totalWeight) * 360;
        startAngle += a;
        return a;
    });

    // Choose a random visual spin amount (for effect) and add small jitter
    const spins = Math.floor(Math.random() * 4) + 4; // 4..7 full spins
    // random jitter across full 360 to ensure variety; final winner will be computed from final rotation
    const jitter = Math.random() * 360;
    const targetRotation = 360 * spins + jitter;

    // set a random duration (speed) per spin
    const duration = (Math.random() * 3 + 3).toFixed(2); // 3.00 - 6.00 seconds
    wheel.style.transition = `transform ${duration}s cubic-bezier(0.33, 1, 0.68, 1)`;

    // apply rotation (accumulate to keep smooth multiple spins)
    currentRotation += targetRotation;
    wheel.style.transform = `rotate(${currentRotation}deg)`;

    // wait for transition end to ask server which segment is at arrow
    const onEnd = (e) => {
        if (e.propertyName !== 'transform') return;
        wheel.removeEventListener('transitionend', onEnd);

        // compute final rotation mod 360 and ask server to determine winner by arrow position
        const finalRotation = currentRotation;
        fetch('/spin?rotation=' + encodeURIComponent(finalRotation)).then(r => r.json()).then(data => {
            document.getElementById('result').innerText = 'Победитель: ' + data.winner;
            btn.disabled = false;
        }).catch(err => {
            document.getElementById('result').innerText = 'Ошибка при запросе.';
            btn.disabled = false;
        });
    };
    wheel.addEventListener('transitionend', onEnd);
}

</script>
</body>
</html>
"""

@app.route("/")
def home():
    return render_template_string(HTML, items=items)

@app.route("/spin")
def spin():
    # New behavior: determine winner based on wheel rotation (arrow position)
    # Expect query parameter 'rotation' (degrees) representing cumulative rotation applied to wheel.
    rotation = request.args.get('rotation', type=float)
    if rotation is None:
        # fallback to previous random behavior if rotation not provided
        rand = random.uniform(0, total_weight)
        cumulative = 0
        for index, (name, weight) in enumerate(items):
            cumulative += weight
            if rand <= cumulative:
                return jsonify({"winner": name, "index": index})
        return jsonify({"winner": items[-1][0], "index": len(items) - 1})

    # compute which segment is at the arrow (arrow points to 0deg at the page).
    # If wheel has been rotated by +rotation degrees (clockwise), then the angle
    # at the top corresponds to pointerAngle = (360 - (rotation % 360)) % 360.
    pointer_angle = (360.0 - (rotation % 360.0)) % 360.0;

    cumulative_angle = 0.0
    for index, (name, weight) in enumerate(items):
        segment_angle = (weight / total_weight) * 360.0
        cumulative_angle += segment_angle
        if pointer_angle < cumulative_angle:
            return jsonify({"winner": name, "index": index})

    # Fallback
    return jsonify({"winner": items[-1][0], "index": len(items) - 1})

if __name__ == "__main__":
    app.run(debug=True)
